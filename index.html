<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>トラッカー サンプル抽出 & MP3変換</title>
    <!-- 1. Tailwind CSS (UI) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. xmp-js (MOD/XM/S3M/IT ローダー) -->
    <script src="https://cdn.jsdelivr.net/npm/xmp-js/dist/xmp.min.js"></script>
    <!-- 3. lamejs (MP3エンコーダ) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
    
    <style>
        /* Interフォントの読み込み */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* スピナーのアニメーション */
        .spinner {
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex items-center justify-center p-4">

    <div class="bg-gray-800 shadow-2xl rounded-2xl p-6 md:p-8 w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-center text-indigo-400 mb-2">トラッカー サンプル抽出ツール</h1>
        <p class="text-center text-gray-400 mb-6">.mod, .xm, .s3m, .it ファイルをアップロードして、含まれるサンプルをMP3でダウンロードします。</p>

        <!-- ファイル入力 -->
        <div class="mb-6">
            <label for="file-upload" class="block text-sm font-medium text-gray-300 mb-2">1. トラッカーファイルを選択</label>
            <input id="file-upload" type="file" accept=".mod,.xm,.s3m,.it" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 transition duration-200 cursor-pointer"/>
        </div>
        
        <!-- サンプルレート設定 -->
        <div class="mb-6">
            <label for="sample-rate" class="block text-sm font-medium text-gray-300 mb-2">2. MP3 サンプルレート</label>
            <select id="sample-rate" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-indigo-500 focus:border-indigo-500">
                <option value="8000">8000 Hz (低い)</option>
                <option value="11025">11025 Hz</option>
                <option value="16000">16000 Hz</option>
                <option value="22050" selected>22050 Hz (推奨)</option>
                <option value="32000">32000 Hz</option>
                <option value="44100">44100 Hz (高い)</option>
            </select>
            <p class="text-xs text-gray-500 mt-1">トラッカーのサンプルは元々低品質な場合があります。22050 Hz程度を推奨します。</p>
        </div>

        <!-- ステータスと結果 -->
        <div id="status-area" class="text-center mb-4 min-h-[2rem]">
            <!-- JSでステータスをここに挿入 -->
        </div>

        <!-- 抽出されたサンプルリスト -->
        <div id="sample-list" class="bg-gray-900 rounded-lg p-4 max-h-96 overflow-y-auto">
            <p class="text-gray-500 text-center">ファイルをロードすると、ここにサンプルが表示されます。</p>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('file-upload');
        const sampleRateSelect = document.getElementById('sample-rate');
        const statusArea = document.getElementById('status-area');
        const sampleList = document.getElementById('sample-list');
        
        // --- 修正点 ---
        // Xmp() ではなく window.Xmp() を使用してインスタンス化します
        let xmp = new window.Xmp(); 
        // --- 修正ここまで ---

        let moduleData = null; // ロードされたモジュールデータを保持

        fileInput.addEventListener('change', handleFileLoad);

        // ファイルが選択されたときの処理
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 以前の結果をクリア
            clearResults();
            setStatus('loading', 'ファイルを読み込んでいます...');

            const reader = new FileReader();
            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                
                try {
                    // xmp-jsでモジュールをロード
                    xmp.loadModule(arrayBuffer);
                    
                    // モジュールデータを取得
                    moduleData = xmp.getModuleData();

                    if (moduleData && moduleData.name && moduleData.samples) {
                        setStatus('success', `ロード完了: ${moduleData.name} (${moduleData.samples.length} サンプル)`);
                        extractSamples();
                    } else {
                        setStatus('error', 'エラー: モジュールデータの読み取りに失敗しました。');
                    }

                } catch (error) {
                    console.error("Module Load Error:", error);
                    // xmp-jsはエラー時に文字列をスローすることがある
                    if (typeof error === 'string') {
                        setStatus('error', `エラー: ${error}`);
                    } else {
                        setStatus('error', `エラー: サポートされていないファイル形式、または破損したファイルです。 (${error.message || ''})`);
                    }
                }
            };
            
            reader.onerror = () => {
                setStatus('error', 'ファイル読み込みエラー。');
            };
            
            reader.readAsArrayBuffer(file);
        }

        // 状態表示をリセット
        function clearResults() {
            sampleList.innerHTML = '<p class="text-gray-500 text-center">ファイルをロードすると、ここにサンプルが表示されます。</p>';
            statusArea.innerHTML = '';
            moduleData = null;
        }

        // ステータス表示を更新
        function setStatus(type, message) {
            let colorClass = 'text-gray-400';
            let icon = '';
            if (type === 'loading') {
                colorClass = 'text-blue-400';
                icon = '<div class="spinner w-4 h-4 border-2 border-blue-400 rounded-full inline-block mr-2"></div>';
            } else if (type === 'success') {
                colorClass = 'text-green-400';
            } else if (type === 'error') {
                colorClass = 'text-red-400';
            }
            statusArea.innerHTML = `<p class="${colorClass}">${icon}${message}</p>`;
        }

        // サンプル抽出とMP3変換の実行
        function extractSamples() {
            if (!moduleData) return;
            
            sampleList.innerHTML = ''; // リストをクリア
            const targetSampleRate = parseInt(sampleRateSelect.value, 10);
            
            if (moduleData.samples.length === 0) {
                 sampleList.innerHTML = '<p class="text-gray-500 text-center">このファイルにはサンプルが含まれていません。</p>';
                 return;
            }

            // xmp-jsのフラグ定数（libxmpから）
            const XMP_SAMPLE_16BIT = 4; // サンプルが16ビットであることを示すフラグ

            // 各サンプルを処理
            for (let i = 0; i < moduleData.samples.length; i++) {
                const sampleInfo = moduleData.samples[i];
                
                const sampleName = sampleInfo.name.trim() || `Sample ${i+1}`;
                const sampleLength = sampleInfo.len; // サンプル長 (フレーム数)
                const sampleData = sampleInfo.data; // Int8Array または Int16Array (xmp-jsの実装による)
                const is16bit = (sampleInfo.flg & XMP_SAMPLE_16BIT) !== 0;

                if (sampleLength <= 0 || !sampleData || sampleData.length === 0) {
                    // 空のサンプルをリストに表示（ダウンロード不可）
                    addSampleToList(i, sampleName, sampleLength, null);
                    continue;
                }
                
                // MP3エンコードは時間がかかるため、
                // UI上は先にリストを表示し、非同期でエンコードする
                
                // プレースホルダーをリストに追加
                const { downloadLink, statusEl } = addSampleToList(i, sampleName, sampleLength, 'encoding');

                // 非同期（setTimeout 0）で重い処理を実行
                setTimeout(() => {
                    try {
                        let pcm16;

                        // 1. 8-bit/16-bit (Int8/Int16) から 16-bit (Int16) PCMへ変換
                        if (is16bit) {
                            // データが16ビットの場合
                            // xmp-jsは16bitデータをInt16Arrayとして返すことを期待
                            if (sampleData instanceof Int16Array) {
                                pcm16 = sampleData;
                            } 
                            // もしInt8Array (バイトバッファ) として返された場合、Int16Arrayに再解釈
                            else if (sampleData instanceof Int8Array) {
                                pcm16 = new Int16Array(sampleData.buffer, sampleData.byteOffset, sampleData.length / 2);
                            } else {
                                throw new Error("不明な16ビットサンプルデータ形式です。");
                            }
                        } else {
                            // データが8ビットの場合 (protrackerと同様、符号付き8bitと仮定)
                            // xmp-jsは8bitデータをInt8Arrayとして返すことを期待
                            if (!(sampleData instanceof Int8Array)) {
                                throw new Error("不明な8ビットサンプルデータ形式です。");
                            }
                            pcm16 = new Int16Array(sampleData.length);
                            for (let j = 0; j < sampleData.length; j++) {
                                pcm16[j] = sampleData[j] << 8; // 8-bit signed を 16-bit に拡張
                            }
                        }

                        // 2. MP3エンコード (lamejs)
                        // モノラル、選択されたサンプルレート、ビットレート128kbps (妥当な品質)
                        const mp3Encoder = new lamejs.Mp3Encoder(1, targetSampleRate, 128);
                        const sampleBlockSize = 1152; // LAMEの推奨ブロックサイズ
                        const mp3Data = [];

                        for (let k = 0; k < pcm16.length; k += sampleBlockSize) {
                            const sampleChunk = pcm16.subarray(k, k + sampleBlockSize);
                            const mp3buf = mp3Encoder.encodeBuffer(sampleChunk);
                            if (mp3buf.length > 0) {
                                mp3Data.push(mp3buf);
                            }
                        }
                        const mp3buf = mp3Encoder.flush(); // 最後のデータをフラッシュ
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }
                        
                        // 3. BlobとダウンロードURLの作成
                        // mp3DataはUint8Arrayの配列。Blobコンストラクタはそれらの配列を受け取れる
                        const blob = new Blob(mp3Data, { type: 'audio/mp3' });
                        const url = URL.createObjectURL(blob);
                        
                        // ダウンロードリンクを有効化
                        statusEl.remove(); // "エンコード中..."を削除
                        downloadLink.href = url;
                        downloadLink.download = `${String(i+1).padStart(2, '0')}_${sampleName.replace(/[^a-z0-9]/gi, '_')}.mp3`;
                        downloadLink.style.display = 'inline-block'; // 表示する
                        downloadLink.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-600');
                        downloadLink.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                        downloadLink.textContent = 'MP3 ダウンロード';

                    } catch (err) {
                        console.error(`Sample ${i} encoding error:`, err);
                        statusEl.textContent = 'エラー';
                        statusEl.classList.remove('text-yellow-400');
                        statusEl.classList.add('text-red-400');
                    }
                }, 0);
            }
        }
        
        // サンプルリストに項目を追加
        function addSampleToList(index, name, length, state) {
            const item = document.createElement('div');
            item.className = 'flex items-center justify-between p-3 bg-gray-800 rounded-lg mb-2 shadow';
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'flex items-center min-w-0'; // min-w-0でtruncateを有効化
            
            const indexSpan = document.createElement('span');
            indexSpan.className = 'text-sm font-bold text-indigo-400 w-8 flex-shrink-0';
            indexSpan.textContent = `${String(index+1).padStart(2, '0')}:`;
            
            const nameSpan = document.createElement('span');
            // truncateとmin-w-0を親に設定
            nameSpan.className = 'text-md text-gray-200 truncate'
            nameSpan.textContent = name;
            nameSpan.title = name;
            
            const lengthSpan = document.createElement('span');
            lengthSpan.className = 'text-xs text-gray-500 ml-3 flex-shrink-0';
            // lengthはバイト数ではなくサンプルフレーム数
            lengthSpan.textContent = `(${length} サンプル)`; 
            
            infoDiv.appendChild(indexSpan);
            infoDiv.appendChild(nameSpan);
            infoDiv.appendChild(lengthSpan);
            
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'flex-shrink-0 ml-4';

            let downloadLink, statusEl;

            if (state === 'encoding') {
                // エンコード中のスピナー
                statusEl = document.createElement('span');
                statusEl.className = 'text-xs text-yellow-400 flex items-center';
                statusEl.innerHTML = '<div class="spinner w-3 h-3 border-2 border-yellow-400 rounded-full inline-block mr-1"></div> エンコード中...';
                controlsDiv.appendChild(statusEl);
                
                // ダミーの非アクティブなリンク (最初は非表示)
                downloadLink = document.createElement('a');
                downloadLink.className = 'opacity-50 cursor-not-allowed px-3 py-1 bg-gray-600 text-white text-xs font-medium rounded-md transition duration-200';
                downloadLink.textContent = 'MP3 ダウンロード';
                downloadLink.style.display = 'none'; // 最初は非表示
                controlsDiv.appendChild(downloadLink);

            } else if (state === null) {
                // 空のサンプル
                statusEl = document.createElement('span');
                statusEl.className = 'text-xs text-gray-600';
                statusEl.textContent = '空のサンプル';
                controlsDiv.appendChild(statusEl);
            }

            item.appendChild(infoDiv);
            item.appendChild(controlsDiv);
            sampleList.appendChild(item);

            // エンコード完了時に切り替えるための要素を返す
            // stateがnullの場合、これらはundefinedになるが、呼び出し元でチェックされている
            return { downloadLink, statusEl };
        }

    </script>
</body>
</html>
